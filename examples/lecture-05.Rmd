---
title: "Lecture-05 Examples"
author: "Christopher Prener, Ph.D."
date: '(`r format(Sys.time(), "%B %d, %Y")`)'
output: 
  github_document: default
  html_notebook: default 
---

## Introduction
This notebook covers basic map production in `R` using a variety of tools. We'll review some of what we discussed during [Lecture-01](https://slu-soc5650.github.io/docs/lecture-01/) and then introduce two new approaches for mapping.

## Dependencies
This notebook requires a variety of packages for working with spatial data:

```{r load-packages}
# tidyverse packages
library(ggplot2)      # plotting data

# spatial packages
library(leaflet)      # interactive maps
library(mapview)      # preview spatial data
library(tmap)         # map layouts
library(sf)           # spatial data tools

# other packages
library(here)         # file path management
library(RColorBrewer) # color palettes
library(viridis)      # color palettes
```

For best results, you should also have PhantomJS installed as well:

```{r install-phantom-js, eval=FALSE}
webshot::install_phantomjs()
```

## Load Data (Lecture-01 Review)
This notebook requires the data stored in `data/example-data/`. Remember that we use `sf::st_read()` to load shapefile data:

```{r load-data}
city <- st_read(here("data", "example-data", "STL_BOUNDARY_City", "STL_BOUNDARY_City.shp"), stringsAsFactors = FALSE)
nhoods <- st_read(here("data", "example-data", "STL_DEMOS_Nhoods", "STL_DEMOS_Nhoods.shp"), stringsAsFactors = FALSE)
```

## Projections
We haven't talked about projections, yet. They are a part of how we render geometric data on two-dimensional maps. ArcGIS Pro is a bit more flexible than `R` packages are when it comes to projections For now, the more important thing to know is that we need to adjust the projection being used for our data. We'll use two projections today:

* WGS 1984 (crs = `4326`)
* UTM 15N (crs = `32615`)

To ensure that our data are projected correctly, we use `sf::st_transform()`:

```{r project-data}
# city boundary
city <- st_transform(city, crs = 32615)
city84 <- st_transform(city, crs = 4326)

# neighborhood demographics
nhoods <- st_transform(nhoods, crs = 32615)
nhoods84 <- st_transform(nhoods, crs = 4326)
```

## Exploring Data
There are two ways we can explore our data - we can inspect them using functions that print particular properties of each object, and we can inspect them visually. 

### Listing Properties
The `utils::str()` function gives us a chance to preivew the data in terms of variable names and the a quick snapshot of the data each variable contains. We can do this for the `city` data:

```{r city-str}
str(city)
```

We can also do this for the `nhoods` data:

```{r nhoods-str}
str(nhoods)
```

### Visually Inspecting Objects

We can also visually inspect the tabular data by clicking on objects in the Enviornment tab or, alternatively, using `View()` in the console - `View(city)`. To get a preview of the spatial data, we can use the `mapview` package's `mapview()` function. Once the map is created, we can alter the basemap by clicking the icon under the zoom in and out buttons. We can preview the tabular data for each feature by clicking on it:

```{r city-view}
mapview(city)
```

Here is the preview for the `nhoods` data:

```{r nhoods-view}
mapview(nhoods)
```

Getting a sense of how the data are structured, both in terms of their tabular attributes and geometric properties, is the first thing you should do when you bring data into `R`.

## Interactive Mapping with `leaflet` (Lecture-01 Review)
### Basic Mapping of Geometric Objects
During Lecture-01, we discussed the creation of interactive maps using the `leaflet` package. [Leaflet](https://leafletjs.com) is a JavaScript library for creating interactive maps. It is primarily focused on web and mobile mapping. The `leaflet` package for `R` provides access to the JavaScript library. 

Leaflet provides a number of basemaps for mapping. If you add map tiles using `addTiles()`, you'll get the open street map basemap. Other basemaps can be added using `addProviderTiles()`. The names of available options can be found using:

```{r leaflet-names}
names(providers)
```

As you can see, there are a ton of choices! We'll use `CartoDB.Positron` here, but feel free to pick one that you like for assignments if we don't specify what you should use. Make sure that your other cartographic selections, such as color, do not clash with your basemap. 

The basic `leaflet` workflow involves piping functions together (the `%>%` operator). Each time to see the pipe, think of the word "then." For example, the following code chunk would read:

1.Take the `city84` object, **then**
2. use it as the basis for creating a `leaflet` object with `leaflet()`, **then**
3. add a basemap using the `CartoDB.Positron` tiles, **then**
4. add polygons and create a popup.

```{r leaflet-city}
city84 %>%
  leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(popup = ~NAME)
```

We can get more into the weeds with the neighborhood data since they have additional features. We can create more detailed popups using the `base::paste()` function and some html tags. The most important html tags to know are:

* `<b>text</b>` - bold text
* `<em>text</em>` - italicized text
* `<br>` - line break

```{r leaflet-nhoods}
nhoods84 %>%  
  leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(popup = paste("<b>Name:</b> ", nhoods84$NHD_NAME, "<br>",
                            "<b>2017 Population:</b> ", round(nhoods84$pop17, digits = 0)))
```

### Mapping Quantities with `leaflet`

If we want to turn this into a themeatic choropleth map, we can add some additional parameters to the `addPolygons()` function. The options included here are:

* `color` - outline ("stroke") color for each polygon
* `weight` - stroke width
* `opacity` - stroke opacity
* `smoothFactor` - allows `leaflet` to simplify polygons depending on zoom
* `fillOpacity` - fill opacity
* `fillColor` - creates the fill itself
* `highlightOptions` - creates effect when mouse drags over specific polygons

What I have here are good default settings for most of these options, but feel free to experiment!

When we created our popup, we want to round our values so that we don't see the very long real number associated with our data. By using `base::round(var, digits = 0)`, we round to the nearest integer. `digits = 2` would give us two decimal places in contrast.

```{r leaflet-nhoods3}
# create color palette
npal <- colorNumeric("YlOrRd", nhoods84$pop17)

# create leaflet object
nhoods84 %>%
  leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    color = "#444444", 
    weight = 1, 
    opacity = 1.0, 
    smoothFactor = 0.5,
    fillOpacity = 0.5,
    fillColor = ~npal(pop17),
    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
    popup = paste("<b>Name:</b> ", nhoods84$NHD_NAME, "<br>",
                  "<b>2017 Population:</b> ", round(nhoods84$pop17, digits = 0))) 
```

Next, we should add a legend to make the map easier to interpret. This is done with the `addLegend()` argument. The `opacity` argument in `addLegend()` should match the `fillOpacity` argument in `addPolygons()`!

```{r leaflet-nhoods4}
# create color palette
npal <- colorNumeric("YlOrRd", nhoods84$pop17)

# create map
nhoods84 %>%
  leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    color = "#444444", 
    weight = 1, 
    opacity = 1.0, 
    smoothFactor = 0.5,
    fillOpacity = 0.5,
    fillColor = ~npal(pop17),
    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
    popup = paste("<b>Name:</b> ", nhoods84$NHD_NAME, "<br>",
                  "<b>2017 Population:</b> ", round(nhoods84$pop17, digits = 0))) %>%
    addLegend(pal = npal, values = ~pop17, opacity = .5, title = "Population (2017)")
```

The colors come from the `RColorBrewer` package. We can use `RColorBrewer::display.brewer.all()` to identify other color ramps:

```{r}
display.brewer.all(type = "seq")
```

We'll try the `YlGnBu` palette on this next map, which normalizes the data but dividing our `AREA` variable (which is the area of each neighborhood in square meters) by `1000000`to convert to square kilometers. We use the `/` mathmatical operator to divide our values, and paraentheses to ensure order of operations is respected. We add a corresponding value to our popup as well:

```{r leaflet-nhoods5}
# create color palette
npal <- colorNumeric("YlGnBu", nhoods84$pop17/(nhoods84$AREA/1000000))

# create map
nhoods84 %>%
  leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    color = "#444444", 
    weight = 1, 
    opacity = 1.0, 
    smoothFactor = 0.5,
    fillOpacity = 0.5,
    fillColor = ~npal(pop17/(AREA/1000000)),
    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
    popup = paste("<b>Name:</b> ", nhoods84$NHD_NAME, "<br>",
                  "<b>2017 Population:</b> ", round(nhoods84$pop17, digits = 0), "<br>",
                  "<b>2017 Population per Square Kilometer:</b> ", 
                      round((nhoods84$pop17/(nhoods84$AREA/1000000)), digits = 0))) %>%
    addLegend(pal = npal, values = ~pop17/(AREA/1000000), opacity = .5, 
              title = "Population Density (2017)")
```

For our final `leaflet` map, we'll change the color ramp again and update the map to focus on 1950 instead of 2017:

```{r leaflet-nhoods6}
# create color palette
npal <- colorNumeric("OrRd", nhoods84$pop50/(nhoods84$AREA/1000000))

# create map
nhoods84 %>%
  leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    color = "#444444", 
    weight = 1, 
    smoothFactor = 0.5,
    opacity = 1.0, 
    fillOpacity = 0.5,
    fillColor = ~npal(pop50/(AREA/1000000)),
    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
    popup = paste("<b>Name:</b> ", nhoods84$NHD_NAME, "<br>",
                  "<b>1950 Population:</b> ", round(nhoods84$pop50, digits = 0), "<br>",
                  "<b>1950 Population per Square Kilometer:</b> ", 
                      round((nhoods84$pop50/(nhoods84$AREA/1000000)), digits = 0))) %>%
    addLegend(pal = npal, values = ~pop50/(AREA/1000000), opacity = .5, 
              title = "Population Density (1950)")
```

## Managing Our Enviornment
With GIS work, our enviornment gets cluttered. As I work on an analysis, I find it useful to remove objects once I know that I am done with them. We use the `base::rm()` function to do this:

```{r remove-wgs84-objects}
rm(city84, nhoods84, npal)
```

## Simple Maps with `ggplot2`
### Basic Mapping of Geometric Objects
`ggplot2` is the premier graphics package for `R`. It is an incredibly powerful visualization tool that increasingly supports spatial work and mapping. The basic `ggplot2` workflow requires chaining together functions with the `+` sign. 

We'll start by creating a `ggplot2` object with the `ggplot()` function, and then adding a "geom", which provides `ggplot2` instructions on how our data should be visualized. We can read these like paragraphs:

1. First, we create an empty `ggplot2` object, **then**
2. we add the `nhoods` data and visualize its geometry.

```{r ggplot2-nhoodSimple}
ggplot() +
  geom_sf(data = nhoods, fill = "#bababa")
```

You can see empty spaces where there are major parks - if we wanted to give these a background color, we could add the `city` layer under our `nhoods` layer. We can also add the `city` layer again on top to give the city border a pronouced outline. `ggplot2` relies on layering different geoms to produce complicated plots. We can assign each geom a specific set of aesthetic characteristics and use data from different objects.

```{r ggplot2-nhoodSimple2}
ggplot() +
  geom_sf(data = city, fill = "#ffffff", color = NA) +
  geom_sf(data = nhoods, fill = "#bababa") +
  geom_sf(data = city, fill = NA, color = "#000000", size = .75)
```

### Mapping Quantities with `ggplot2`
If we wanted to start to map data instead of just the geometric properties, we would specify an "aesthetic mapping" using `mapping= aes()` in the geom of interest. Here, we create a fill that is the product of taking the population in 2017 and normalizing it by square kilometers as we did in the `leaflet` section above. We provide additional instructions about how our data should be colored with the `scale_fill_distiller()` function, which gives us access to the `RColorBrewer` palettes.

```{r ggplot2-nhood1}
# create ggplot object
ggplot() +
  geom_sf(data = city, fill = "#ffffff", color = NA) +
  geom_sf(data = nhoods, mapping = aes(fill = pop17/(AREA/1000000))) +
  geom_sf(data = city, fill = NA, color = "#000000", size = .75) +
  scale_fill_distiller(palette = "Greens", trans = "reverse") -> ggplot_17_1

# print object
ggplot_17_1
```

This map also stores our `ggplot` object in its own space in our global enviornment. This allows us the ability to update it later, and to more easily save it.

### Creating Map Layouts with `ggplot2`

Before we save it, however, we should create a more substantial layout. We'll use the `name` argument in `scale_fill_distiller()` to name the legend, the `labs()` function to add text to our layout, and `theme_minimal()` to remove some of the default `ggplot2` theme elements:

```{r ggplot2-nhood2}
# create ggplot object
ggplot() +
  geom_sf(data = city, fill = "#ededed", color = NA) +
  geom_sf(data = nhoods, mapping = aes(fill = pop17/(AREA/1000000))) +
  geom_sf(data = city, fill = NA, color = "#000000", size = .75) +
  scale_fill_distiller(palette = "Greens", trans = "reverse", name = "Population per\nSquare Kilometer") +
  labs(
    title = "Population Density (2017)",
    subtitle = "Neighborhoods in St. Louis, MO",
    caption = "Map by Christopher Prener, Ph.D."
  ) +
  theme_minimal() -> ggplot_17_2

# print object
ggplot_17_2
```

Next, to save our map, we use the `ggsave()` function:

```{r ggplot2-save-nhood2}
ggsave(here("examples", "results", "ggplot2_popDensity17.png"), ggplot_17_2, dpi = 500)
```

We can repeat this process for the 1950 data:

```{r ggplot2-nhood3}
# create ggplot object
ggplot() +
  geom_sf(data = city, fill = "#ededed", color = NA) +
  geom_sf(data = nhoods, mapping = aes(fill = pop50/(AREA/1000000))) +
  geom_sf(data = city, fill = NA, color = "#000000", size = .75) +
  scale_fill_distiller(palette = "Blues", trans = "reverse", name = "Population per\nSquare Kilometer") +
  labs(
    title = "Population Density (1950)",
    subtitle = "Neighborhoods in St. Louis, MO",
    caption = "Map by Christopher Prener, Ph.D."
  ) +
  theme_minimal() -> ggplot_17_3

# print object
ggplot_17_3
```

To save our map, we again use the `ggsave()` function:

```{r ggplot2-save-nhood3}
ggsave(here("examples", "results", "ggplot2_popDensity50.png"), ggplot_17_3, dpi = 500)
```

### Using `viridis` with `ggplot2`

The other option for color palettes is the `viridis` family of palettes. These are specified by replacing `scale_fill_distiller()` with `scale_fill_viridis()`. The `option` argument replaces `palette`, but `name` has the same functionality:

```{r ggplot2-nhood4}
# create ggplot object
ggplot() +
  geom_sf(data = city, fill = "#ededed", color = NA) +
  geom_sf(data = nhoods, mapping = aes(fill = pop17/(AREA/1000000))) +
  geom_sf(data = city, fill = NA, color = "#000000", size = .75) +
  scale_fill_viridis(option = "cividis", name = "Population per\nSquare Kilometer") +
  labs(
    title = "Population Density (2017)",
    subtitle = "Neighborhoods in St. Louis, MO",
    caption = "Map by Christopher Prener, Ph.D."
  ) +
  theme_minimal() -> ggplot_17_4

# print object
ggplot_17_4
```

The other options for `viridis` are `viridis`, `magma`, `plasma`, and `inferno`:

```{r ggplot2-nhood5}
# create ggplot object
ggplot() +
  geom_sf(data = city, fill = "#ededed", color = NA) +
  geom_sf(data = nhoods, mapping = aes(fill = pop17/(AREA/1000000))) +
  geom_sf(data = city, fill = NA, color = "#000000", size = .75) +
  scale_fill_viridis(option = "viridis", name = "Population per\nSquare Kilometer") +
  labs(
    title = "Population Density (2017)",
    subtitle = "Neighborhoods in St. Louis, MO",
    caption = "Map by Christopher Prener, Ph.D."
  ) +
  theme_minimal() -> ggplot_17_5

# print object
ggplot_17_5
```

To save our map, we again use the `ggsave()` function:

```{r ggplot2-save-nhood5}
ggsave(here("examples", "results", "ggplot2_popDensity17_2.png"), ggplot_17_5, dpi = 500)
```

### Clean-up Enviornment Again
We'll get rid of the `ggplot2` objects we've created:

```{r clean-up-ggplot2-objects}
rm(ggplot_17_1, ggplot_17_2, ggplot_17_3, ggplot_17_4, ggplot_17_5)
```

## Map Layouts with `tmap`
`tmap` uses a similar logic to `ggplot2` - it layers elements on top of each other to produce maps. It is dedicated to working with spatial data, however, and has some features that `ggplot2` does not. 

### Basic Mapping of Geometric Objects
We'll start with a basic map that, like we have previously, just display the geometry of the city's neighborhoods. Similar to `ggplot2`, functions are chainted together with the `+` sign. We can read these like paragraphs:

1. First, we take the `nhoods` data, **then**
2. we create our `tmap` layer out of its shape, **then**
3. we add a fill using our layer, **then**
4. we add borders using our layer.
  
```{r tmap-simple}
nhoods %>%
  tm_shape() +
    tm_fill() +
    tm_borders() 
```

### Mapping Quantities with `tmap`
Like `ggplot2`, we can plot quantities using the `tm_polygons()` function. The `palette` argument accepts names of both `RColorBrewer` and `viridis` palettes.

```{r tmap-quantities}
nhoods %>%
  tm_shape() +
    tm_polygons(col = "pop17", palette = "Greens")
```

Notice that this is a map of population counts, and is therefore not normalized. `tamp` makes the normalization process easy, with the `convert2density` argument:

```{r tmap-density}
nhoods %>%
  tm_shape() +
    tm_polygons(col = "pop17", palette = "Reds", convert2density = TRUE)
```

We can shrink (or grow) the number of classes using the `n` argument in `tm_polygons`, though I've found it to be unreliable occasionally:

```{r tmap-density2}
nhoods %>%
  tm_shape() +
    tm_polygons(col = "pop17", 
                palette = "BuPu", 
                n = 3,
                convert2density = TRUE)
```

We can also change the breaks are calculated. `tmap` uses the `"pretty"` approach by default, whereas ArcGIS uses the `"jenks"` approach. We can mirror ArcGIS by specifying `"jenks"`, and can continue to adjust the number of breaks: 

```{r tmap-jenks}
nhoods %>%
  tm_shape() +
    tm_polygons(col = "pop17", 
                palette = "BuPu", 
                style = "jenks",
                n = 6,
                convert2density = TRUE)
```

Another option is to use the `"equal"` approach to breaks, which divides our observations into equally sized classes:

```{r tmap-equal}
nhoods %>%
  tm_shape() +
    tm_polygons(col = "pop17", 
                palette = "BuPu", 
                style = "equal",
                n = 6,
                convert2density = TRUE)
```

### Creating Map Layouts with `tmap`
Once we have a map we like, we can begin to build a layout around it. Like with our `ggplot2` map layout, we'll add the city underneath by adding a shape below `nhoods`. We'll use the `city` data for this. We'll add the `city` on top as well to achieve that outline effect we discussed with `ggplot2` as well:

```{r tmap-add-background}
tm_shape(city) +
  tm_fill(fill = "ebebeb") + 
  tm_shape(nhoods) +
  tm_polygons(col = "pop17", 
              palette = "viridis", 
              style = "jenks",
              convert2density = TRUE) +
  tm_shape(city) +
  tm_borders(lwd = 2)
```

Notice how we have to add each layer using `tm_shape()` before beginning to modify its astheic properties.

We can also add adornments to our map layouts, including a scale bar (with `tm_scale_bar()`):

```{r tmap-add-scale-bar}
tm_shape(city) +
  tm_fill(fill = "ebebeb") + 
  tm_shape(nhoods) +
  tm_polygons(col = "pop17", 
              palette = "viridis", 
              style = "jenks",
              convert2density = TRUE) +
  tm_shape(city) +
  tm_borders(lwd = 2) +
  tm_scale_bar() 
```

Once we have a layout that we like, we can use `tm_layout()` to add a title and move the legend if necessary.  

```{r tmap-layout1}
# create tmap object
tm_shape(city) +
  tm_fill(fill = "ebebeb") + 
  tm_shape(nhoods) +
  tm_polygons(col = "pop17", 
              palette = "viridis", 
              style = "jenks",
              convert2density = TRUE,
              title = "Population per\nSquare Kilomer") +
  tm_shape(city) +
  tm_borders(lwd = 2) +
  tm_scale_bar() +
  tm_layout(
    title = "Population Density (2017)",
    frame = FALSE,
    legend.outside = TRUE,
    legend.position = c("left", "bottom")) -> tmap_17_1

# print object
tmap_17_1
```

`tmap` lacks the ability to add subtitles and captions to plot layouts, which is a drawback. Once we have our object created, we can save it using `tmap_save()`, which is functionally the same as `ggplot2::ggsave()` but with slightly different arguments:

```{r tmap-save-layout1}
tmap_save(tm = tmap_17_1, filename = here("examples", "results", "tamp_popDensity17_1.png"), dpi = 500)
```

### Adding Histograms
One neat feature that `tmap` has is the ability to add a histogram of the mapped variable to the legend as well. This is done by adding `legend.hist = TRUE` to the `tm_polygons()` function:

```{r tmap-layout2}
# create tmap object
tm_shape(city) +
  tm_fill(fill = "ebebeb") + 
  tm_shape(nhoods) +
  tm_polygons(col = "pop17", 
              palette = "GnBu", 
              style = "jenks",
              convert2density = TRUE,
              title = "Population per\nSquare Kilomer",
              legend.hist = TRUE) +
  tm_shape(city) +
  tm_borders(lwd = 2) +
  tm_scale_bar() +
  tm_layout(
    title = "Population Density (2017)",
    frame = FALSE,
    legend.outside = TRUE,
    legend.position = c("left", "bottom")) -> tmap_17_2

# print object
tmap_17_2
```

Once again, we can save this using `tmap_save()`:

```{r tmap-save-layout2}
tmap_save(tm = tmap_17_2, filename = here("examples", "results", "tamp_popDensity17_2.png"), dpi = 500)
```

```{r move-to-docs, include=FALSE}
# you do need to include this in any notebook you create for this class
fs::file_copy(here::here("examples", "lecture-05.nb.html"), here::here("docs", "index.nb.html"))
```
